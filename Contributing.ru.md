# Контрибьютинг & внутреннее устройство

//Мне было лень писать гайд по контрибьютингу на английском

## Как оно работает

Для использования нормальными людьми задуманы целых две версии апи:

* VKApi - принимает параметры, отдаёт объекты
* RawApi - принимает такие же параметры, но плюется json-строками.

Обработка запроса происходит примерно так:

1. Дёргается метод VKApi/RawApi
2. VKApi/RawApi вызывает аналогичный метод у RequestApi, получая сформированный запрос(vkrequest<T>).
3. Запрос передаётся Executor'у в ExecAsync/ExecRawAsync
4. Executor(на данный момент это [JsonExecutor](Sources/Core/Executors/JsonExecutor)) строит HTTP-запрос по VKRequest'у и выполняет его.
5. Если был вызван ExecRawAsync, Executor возвращает полученные данные в виде строке без обработки.
6. Executor десериализует полученные данные.
7. Если свойство Error отлично от null, бросается исключение.
8. Наружу возвращаются десериализованные данные.

## Добавление методов

### Методы

Все методы API описаны в [Sources/VKSharp/Api/Generated/VkSharpFuncs.xml](Sources/VKSharp/Api/Generated/VKSharpFuncs.xml). Формат описан в [соответствующем XSD](Sources/VKSharp/Api/Generated/VkSharpFuncs.xsd). Автокомплит в студии иногда отваливается, но проблема на их стороне.

Пример описания метода:

```XML
<Method
    Name="friends.get"              <!--Имя метода-->

    Type="EntityList&lt;int&gt;"    <!--Возвращаемый тип.
            Если в доках сказано, что возвращается "response:1", следует писать void.-->
    NameSuffix="Satan"              <!--Кастомный суффикс для разрешения конфликтов между методами с разными hardcoded params-->
    NeedToken="false"           <!--Необходима ли авторизация для вызова-->

    Pageable="100"              <!--[Опциональный] Добавляет параметры offset и count.
           Значение параметра будет дефолтным значением count-->
>
<Params>                        <!--Параметры-->
    <Param
           Name="user_id"       <!--Имя параметра. Писать в том виде, как в ВК.
           Генератор сам приведёт к camelCase в коде.-->

           Type="int?"          <!--Тип-->

           Default="null" />    <!--[Опциональный] Дефолтное значение-->

           <!--Custom -- cвоё преобразование к строке с бледжеком и шлюхами.
                #name будет заменено на имя переменной.
                Стандартные преобразования описываются в SharedFuncs.tt-->

    <Param Name="list_id" Type="int?" Default="null" />
    <Param Name="order" Type="UserSortOrder" Default="UserSortOrder.ById" />

            <!--Если последний параметр является массивом, он автоматически станет params-->
</Params>
<Hardcoded>
<!--
Захардкоженные параметры.
Параметры, которые невидимы для юзера(тот, который юзер либы, а не end user), но будут добавлены в запрос.
Применение: методы, которые при разных значениях параметра отдают данные в разных форматах.
Пример: users.get, который отдаёт список интов, если параметр fields пуст и
массив юзеров, если там есть любое значение(включая невалидные)
-->
    <HardcodedParam Name="fields" Value=""/>
</Hardcoded>
</Method>
```

Исходный код и список готовых методов генерируется из него T4-шаблонами из той же папки:

* [RequestApi.tt](Sources/VKSharp/Api/Generated/RequestApi.tt) - реквесты
* [RawApi.tt](Sources/VKSharp/Api/Generated/RawApi.tt) - сырое апи
* [VkApi.tt](Sources/VKSharp/Api/Generated/VkApi.tt) - апи с объектами
* [ImplementedMethods.tt](Sources/VKSharp/Api/Generated/ImplementedMethods.tt) - список готовых методов

Студия запускает генератор при сохранении шаблона.

### Типы

* Файлы с исходниками лежат в /ReturnTypes/, но имеют неймспес VKSharp.Core.*
* Имена свойств/энамов пишутся в стандартном CamelCase - сериализатор автоматически преобразует из snake_case, в котором отдаёт ВК.